# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: event/v1/common.proto, event/v1/event.proto, event/v1/booking.proto, event/v1/closure.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List, Optional

import betterproto
import grpclib


class SlotStatus(betterproto.Enum):
    SLOT_STATUS_UNSPECIFIED = 0
    SLOT_STATUS_AVAILABLE = 1
    SLOT_STATUS_FULL = 2
    SLOT_STATUS_CLOSED = 3


class EventStatus(betterproto.Enum):
    EVENT_STATUS_UNSPECIFIED = 0
    EVENT_STATUS_ACTIVE = 1
    EVENT_STATUS_CANCELED = 2
    EVENT_STATUS_CLOSED = 3
    EVENT_STATUS_FULL = 4
    EVENT_STATUS_DISABLED = 5


class EventType(betterproto.Enum):
    EVENT_TYPE_UNSPECIFIED = 0
    EVENT_TYPE_EVENT = 1
    EVENT_TYPE_TASK = 2
    EVENT_TYPE_MEETING = 3


@dataclass
class TimeData(betterproto.Message):
    timezone: str = betterproto.string_field(1)
    date_time: str = betterproto.string_field(2)


@dataclass
class Slot(betterproto.Message):
    id: str = betterproto.string_field(1)
    event_id: str = betterproto.string_field(2)
    start: "TimeData" = betterproto.message_field(3)
    end: "TimeData" = betterproto.message_field(4)
    capacity: int = betterproto.int32_field(5)
    status: "SlotStatus" = betterproto.enum_field(6)
    created_at: int = betterproto.int64_field(7)
    updated_at: int = betterproto.int64_field(8)


@dataclass
class Filters(betterproto.Message):
    from_: str = betterproto.string_field(1)
    to: str = betterproto.string_field(2)
    organizer_key: str = betterproto.string_field(3)
    status: "EventStatus" = betterproto.enum_field(5)
    event_type: "EventType" = betterproto.enum_field(6)
    booking_holder_key: str = betterproto.string_field(8)
    slot_id: str = betterproto.string_field(9)


@dataclass
class Event(betterproto.Message):
    id: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2)
    event_type: "EventType" = betterproto.enum_field(3)
    status: "EventStatus" = betterproto.enum_field(4)
    start: "TimeData" = betterproto.message_field(5)
    end: "TimeData" = betterproto.message_field(6)
    recurrence_rule: str = betterproto.string_field(7)
    organizer_key: str = betterproto.string_field(8)
    cancellation: "Cancellation" = betterproto.message_field(9)
    overlap: bool = betterproto.bool_field(10)
    slots: List["Slot"] = betterproto.message_field(11)
    slot_duration: int = betterproto.int64_field(12)
    capacity: int = betterproto.int32_field(13)
    created_at: int = betterproto.int64_field(14)
    updated_at: int = betterproto.int64_field(15)


@dataclass
class Cancellation(betterproto.Message):
    canceled_by: str = betterproto.string_field(1)
    reason: str = betterproto.string_field(2)
    created_at: "TimeData" = betterproto.message_field(3)


@dataclass
class CreateEventRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    start: str = betterproto.string_field(2)
    end: str = betterproto.string_field(3)
    organizer_key: str = betterproto.string_field(5)
    slot_duration: int = betterproto.int64_field(6)
    capacity: int = betterproto.int32_field(7)
    slot_capacity: int = betterproto.int32_field(8)
    recurrence_rule: str = betterproto.string_field(9)
    event_type: "EventType" = betterproto.enum_field(10)


@dataclass
class CreateEventResponse(betterproto.Message):
    event: "Event" = betterproto.message_field(1)


@dataclass
class GetEventRequest(betterproto.Message):
    id: str = betterproto.string_field(1)


@dataclass
class GetEventResponse(betterproto.Message):
    event: "Event" = betterproto.message_field(1)


@dataclass
class ListEventsRequest(betterproto.Message):
    filters: "Filters" = betterproto.message_field(1)


@dataclass
class ListEventsResponse(betterproto.Message):
    events: List["Event"] = betterproto.message_field(1)


@dataclass
class UpdateEventRequest(betterproto.Message):
    id: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2)
    start: str = betterproto.string_field(3)
    end: str = betterproto.string_field(4)
    capacity: int = betterproto.int32_field(7)
    slot_capacity: int = betterproto.int32_field(8)
    recurrence_rule: str = betterproto.string_field(9)


@dataclass
class UpdateEventResponse(betterproto.Message):
    event: "Event" = betterproto.message_field(1)


@dataclass
class DeleteEventRequest(betterproto.Message):
    id: str = betterproto.string_field(1)


@dataclass
class DeleteEventResponse(betterproto.Message):
    message: str = betterproto.string_field(1)


@dataclass
class CancelEventRequest(betterproto.Message):
    id: str = betterproto.string_field(1)
    canceled_by: str = betterproto.string_field(2)
    reason: str = betterproto.string_field(3)


@dataclass
class CancelEventResponse(betterproto.Message):
    event: "Event" = betterproto.message_field(1)


@dataclass
class GetTimelineRequest(betterproto.Message):
    filters: "Filters" = betterproto.message_field(1)


@dataclass
class GetTimelineResponse(betterproto.Message):
    events: List["Event"] = betterproto.message_field(1)


@dataclass
class GetAvailableDatesRequest(betterproto.Message):
    filters: "Filters" = betterproto.message_field(1)


@dataclass
class GetAvailableDatesResponse(betterproto.Message):
    dates: List[str] = betterproto.string_field(1)


@dataclass
class Booking(betterproto.Message):
    id: str = betterproto.string_field(1)
    booking_holder_key: str = betterproto.string_field(2)
    slot_id: str = betterproto.string_field(3)
    slot: "Slot" = betterproto.message_field(4)
    date_time: "TimeData" = betterproto.message_field(5)
    persons: int = betterproto.int32_field(6)
    created_at: int = betterproto.int64_field(7)
    updated_at: int = betterproto.int64_field(8)
    organizer_key: str = betterproto.string_field(9)


@dataclass
class CreateBookingRequest(betterproto.Message):
    booking_holder_key: str = betterproto.string_field(1)
    slot_id: str = betterproto.string_field(2)
    date_time: str = betterproto.string_field(3)
    persons: int = betterproto.int32_field(4)


@dataclass
class CreateBookingResponse(betterproto.Message):
    booking: "Booking" = betterproto.message_field(1)


@dataclass
class GetBookingRequest(betterproto.Message):
    id: str = betterproto.string_field(1)


@dataclass
class GetBookingResponse(betterproto.Message):
    booking: "Booking" = betterproto.message_field(1)


@dataclass
class DeleteBookingRequest(betterproto.Message):
    id: str = betterproto.string_field(1)


@dataclass
class DeleteBookingResponse(betterproto.Message):
    message: str = betterproto.string_field(1)


@dataclass
class ListBookingsRequest(betterproto.Message):
    filters: "Filters" = betterproto.message_field(1)


@dataclass
class ListBookingsResponse(betterproto.Message):
    bookings: List["Booking"] = betterproto.message_field(1)


@dataclass
class Closure(betterproto.Message):
    id: str = betterproto.string_field(1)
    closing_from: "TimeData" = betterproto.message_field(2)
    closing_to: "TimeData" = betterproto.message_field(3)
    organizer_key: str = betterproto.string_field(5)
    created_at: int = betterproto.int64_field(6)
    updated_at: int = betterproto.int64_field(7)


@dataclass
class CreateClosureRequest(betterproto.Message):
    closing_from: str = betterproto.string_field(1)
    closing_to: str = betterproto.string_field(2)
    organizer_key: str = betterproto.string_field(3)


@dataclass
class CreateClosureResponse(betterproto.Message):
    closure: "Closure" = betterproto.message_field(1)


@dataclass
class UpdateClosureRequest(betterproto.Message):
    id: str = betterproto.string_field(1)
    closing_from: str = betterproto.string_field(2)
    closing_to: str = betterproto.string_field(3)


@dataclass
class UpdateClosureResponse(betterproto.Message):
    closure: "Closure" = betterproto.message_field(1)


@dataclass
class DeleteClosureRequest(betterproto.Message):
    id: str = betterproto.string_field(1)


@dataclass
class DeleteClosureResponse(betterproto.Message):
    message: str = betterproto.string_field(1)


@dataclass
class ListClosuresRequest(betterproto.Message):
    filters: "Filters" = betterproto.message_field(1)


@dataclass
class ListClosuresResponse(betterproto.Message):
    closures: List["Closure"] = betterproto.message_field(1)


class EventServiceStub(betterproto.ServiceStub):
    async def create_event(
        self,
        *,
        name: str = "",
        start: str = "",
        end: str = "",
        organizer_key: str = "",
        slot_duration: int = 0,
        capacity: int = 0,
        slot_capacity: int = 0,
        recurrence_rule: str = "",
        event_type: "EventType" = 0,
    ) -> CreateEventResponse:
        request = CreateEventRequest()
        request.name = name
        request.start = start
        request.end = end
        request.organizer_key = organizer_key
        request.slot_duration = slot_duration
        request.capacity = capacity
        request.slot_capacity = slot_capacity
        request.recurrence_rule = recurrence_rule
        request.event_type = event_type

        return await self._unary_unary(
            "/event.v1.EventService/CreateEvent",
            request,
            CreateEventResponse,
        )

    async def get_event(self, *, id: str = "") -> GetEventResponse:
        request = GetEventRequest()
        request.id = id

        return await self._unary_unary(
            "/event.v1.EventService/GetEvent",
            request,
            GetEventResponse,
        )

    async def list_events(
        self, *, filters: Optional["Filters"] = None
    ) -> ListEventsResponse:
        request = ListEventsRequest()
        if filters is not None:
            request.filters = filters

        return await self._unary_unary(
            "/event.v1.EventService/ListEvents",
            request,
            ListEventsResponse,
        )

    async def update_event(
        self,
        *,
        id: str = "",
        name: str = "",
        start: str = "",
        end: str = "",
        capacity: int = 0,
        slot_capacity: int = 0,
        recurrence_rule: str = "",
    ) -> UpdateEventResponse:
        request = UpdateEventRequest()
        request.id = id
        request.name = name
        request.start = start
        request.end = end
        request.capacity = capacity
        request.slot_capacity = slot_capacity
        request.recurrence_rule = recurrence_rule

        return await self._unary_unary(
            "/event.v1.EventService/UpdateEvent",
            request,
            UpdateEventResponse,
        )

    async def delete_event(self, *, id: str = "") -> DeleteEventResponse:
        request = DeleteEventRequest()
        request.id = id

        return await self._unary_unary(
            "/event.v1.EventService/DeleteEvent",
            request,
            DeleteEventResponse,
        )

    async def cancel_event(
        self, *, id: str = "", canceled_by: str = "", reason: str = ""
    ) -> CancelEventResponse:
        request = CancelEventRequest()
        request.id = id
        request.canceled_by = canceled_by
        request.reason = reason

        return await self._unary_unary(
            "/event.v1.EventService/CancelEvent",
            request,
            CancelEventResponse,
        )

    async def get_timeline(
        self, *, filters: Optional["Filters"] = None
    ) -> GetTimelineResponse:
        request = GetTimelineRequest()
        if filters is not None:
            request.filters = filters

        return await self._unary_unary(
            "/event.v1.EventService/GetTimeline",
            request,
            GetTimelineResponse,
        )

    async def get_available_dates(
        self, *, filters: Optional["Filters"] = None
    ) -> GetAvailableDatesResponse:
        request = GetAvailableDatesRequest()
        if filters is not None:
            request.filters = filters

        return await self._unary_unary(
            "/event.v1.EventService/GetAvailableDates",
            request,
            GetAvailableDatesResponse,
        )


class BookingServiceStub(betterproto.ServiceStub):
    async def create_booking(
        self,
        *,
        booking_holder_key: str = "",
        slot_id: str = "",
        date_time: str = "",
        persons: int = 0,
    ) -> CreateBookingResponse:
        request = CreateBookingRequest()
        request.booking_holder_key = booking_holder_key
        request.slot_id = slot_id
        request.date_time = date_time
        request.persons = persons

        return await self._unary_unary(
            "/event.v1.BookingService/CreateBooking",
            request,
            CreateBookingResponse,
        )

    async def get_booking(self, *, id: str = "") -> GetBookingResponse:
        request = GetBookingRequest()
        request.id = id

        return await self._unary_unary(
            "/event.v1.BookingService/GetBooking",
            request,
            GetBookingResponse,
        )

    async def list_bookings(
        self, *, filters: Optional["Filters"] = None
    ) -> ListBookingsResponse:
        request = ListBookingsRequest()
        if filters is not None:
            request.filters = filters

        return await self._unary_unary(
            "/event.v1.BookingService/ListBookings",
            request,
            ListBookingsResponse,
        )

    async def delete_booking(self, *, id: str = "") -> DeleteBookingResponse:
        request = DeleteBookingRequest()
        request.id = id

        return await self._unary_unary(
            "/event.v1.BookingService/DeleteBooking",
            request,
            DeleteBookingResponse,
        )


class ClosureServiceStub(betterproto.ServiceStub):
    async def create_closure(
        self, *, closing_from: str = "", closing_to: str = "", organizer_key: str = ""
    ) -> CreateClosureResponse:
        request = CreateClosureRequest()
        request.closing_from = closing_from
        request.closing_to = closing_to
        request.organizer_key = organizer_key

        return await self._unary_unary(
            "/event.v1.ClosureService/CreateClosure",
            request,
            CreateClosureResponse,
        )

    async def list_closures(
        self, *, filters: Optional["Filters"] = None
    ) -> ListClosuresResponse:
        request = ListClosuresRequest()
        if filters is not None:
            request.filters = filters

        return await self._unary_unary(
            "/event.v1.ClosureService/ListClosures",
            request,
            ListClosuresResponse,
        )

    async def update_closure(
        self, *, id: str = "", closing_from: str = "", closing_to: str = ""
    ) -> UpdateClosureResponse:
        request = UpdateClosureRequest()
        request.id = id
        request.closing_from = closing_from
        request.closing_to = closing_to

        return await self._unary_unary(
            "/event.v1.ClosureService/UpdateClosure",
            request,
            UpdateClosureResponse,
        )

    async def delete_closure(self, *, id: str = "") -> DeleteClosureResponse:
        request = DeleteClosureRequest()
        request.id = id

        return await self._unary_unary(
            "/event.v1.ClosureService/DeleteClosure",
            request,
            DeleteClosureResponse,
        )
